"use strict";

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.string.replace");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMetricType = exports.getMetricDeleted = exports.getMetricAdded = exports.calculateCacheInvalidation = exports.getModuleName = exports.getAssetName = exports.getFileType = void 0;

var _round2 = _interopRequireDefault(require("lodash/round"));

var _map2 = _interopRequireDefault(require("lodash/map"));

var _last2 = _interopRequireDefault(require("lodash/last"));

var _metrics = require("../utils/metrics");

var _config = require("../config");

var _metrics2 = require("./metrics");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const FILENAME_HASH_PATTERN = /[.|-][a-f0-9]{5,32}$/;

const getFileType = filename => {
  const fileType = Object.entries(_config.FILE_TYPE_PATTERNS).find(([, pattern]) => pattern.test(filename));
  return fileType ? fileType[0] : _config.FILE_TYPE_OTHER;
};
/**
 * Extract (guess) filename from a hashed filename
 */


exports.getFileType = getFileType;

const getAssetName = assetFilepath => {
  if (!assetFilepath) {
    return '';
  }

  const pathParts = assetFilepath.split('/');
  const dirname = pathParts.slice(0, -1).join('/');
  const filename = (0, _last2.default)(pathParts);
  const filenameParts = filename.split('.');
  const {
    basename,
    extension
  } = filenameParts.slice(-2, -1).join('') === 'min' ? {
    basename: filenameParts.slice(0, -2).join('.'),
    extension: filenameParts.slice(-2).join('.')
  } : {
    basename: filenameParts.slice(0, -1).join('.'),
    extension: filenameParts.slice(-1).join('.')
  };
  return `${dirname ? `${dirname}/` : ''}${basename.replace(FILENAME_HASH_PATTERN, '')}.${extension}`;
}; // css ./node_modules/css-loader/dist/cjs.js??ref--6-0!./src/assets/styles/default.styl


exports.getAssetName = getAssetName;
const NAME_WITH_LOADERS = /!/; // ./src/index.jsx + 27 modules

const NAME_WITH_MODULES = /\s\+\s\d*\smodules$/;

const getModuleName = moduleLabel => {
  if (!moduleLabel) {
    return '';
  }

  if (NAME_WITH_LOADERS.test(moduleLabel)) {
    return (0, _last2.default)(moduleLabel.split(NAME_WITH_LOADERS));
  }

  if (NAME_WITH_MODULES.test(moduleLabel)) {
    return moduleLabel.replace(NAME_WITH_MODULES, '');
  }

  return moduleLabel;
};
/*
 * Calculate cache invalidation metric on the baseline data
 *
 * The metric is the ratio between the total file size of the files that have changed (exclude
 * deleted, added) and the total file size
 */


exports.getModuleName = getModuleName;

const calculateCacheInvalidation = rows => {
  let cached = 0;
  let invalidated = 0;
  rows.forEach(({
    changed,
    added,
    deleted,
    runs
  }) => {
    // Added and deleted files do not count towards the caching index
    if (added || deleted) {
      return;
    }

    if (changed) {
      invalidated += runs[1].value;
    }

    cached += runs[1].value;
  });

  if (cached === 0) {
    return 0;
  }

  return (0, _round2.default)(invalidated / cached * 100, 2);
};

exports.calculateCacheInvalidation = calculateCacheInvalidation;

const getMetricAdded = runs => {
  const [current, baseline] = (0, _map2.default)(runs, 'value');
  return Boolean(current !== null && !baseline);
};

exports.getMetricAdded = getMetricAdded;

const getMetricDeleted = runs => {
  const [current, baseline] = (0, _map2.default)(runs, 'value');
  return Boolean(baseline !== null && !current);
};
/**
 * Get webpack metric data
 *
 * @param {String} key - Webpack metric key
 * @return {Object} Metric data
 */


exports.getMetricDeleted = getMetricDeleted;
const getMetricType = (0, _metrics.createGetMetricType)(_metrics2.metrics);
exports.getMetricType = getMetricType;